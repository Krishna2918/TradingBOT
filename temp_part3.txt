                            chatgpt_weight = 0.3  # 30% weight to ChatGPT
                            original_weight = 0.7  # 70% weight to original signals
                            
                            # Adjust confidence based on ChatGPT
                            chatgpt_confidence = chatgpt_decision.get('confidence', 5) / 10.0
                            combined_confidence = (
                                best_signal['total_strength'] * original_weight + 
                                chatgpt_confidence * chatgpt_weight
                            )
                            
                            # Update decision if ChatGPT agrees or provides strong signal
                            if (chatgpt_decision.get('action') == best_signal['action'] or 
                                chatgpt_confidence > 0.7):
                                
                                best_signal['total_strength'] = combined_confidence
                                best_signal['reasons'].append(
                                    f"ChatGPT: {chatgpt_decision.get('reasoning', 'AI analysis')}"
                                )
                                
                                logger.info(f"âœ… ChatGPT enhanced decision for {best_signal['symbol']}")
                                logger.info(f"  ðŸ¤– ChatGPT confidence: {chatgpt_confidence*100:.1f}%")
                                logger.info(f"  ðŸ“Š Combined confidence: {combined_confidence*100:.1f}%")
                            
                except Exception as e:
                    logger.warning(f"âš ï¸ ChatGPT analysis failed: {e}")
            
            if best_signal['total_strength'] >= 1.0:  # Threshold
                decision['action'] = best_signal['action']
                decision['symbol'] = best_signal['symbol']
                decision['confidence'] = min(best_signal['total_strength'] / len(signals), 1.0)
                decision['reasoning'] = best_signal['reasons']
                
                # Calculate position size
                if decision['action'] == 'BUY':
                    decision['shares'] = self._calculate_position_size(
                        symbol=decision['symbol'],
                        confidence=decision['confidence'],
                        analysis=analysis
                    )
                    # Get current price
                    if analysis.get('market_data', {}).get(decision['symbol']) is not None:
                        df = analysis['market_data'][decision['symbol']]
                        decision['price'] = df['Close'].iloc[-1] if not df.empty else 0.0
                elif decision['action'] == 'SELL':
                    if decision['symbol'] in self.holdings:
                        decision['shares'] = self.holdings[decision['symbol']]['shares']
                        # Get current price
                        if analysis.get('market_data', {}).get(decision['symbol']) is not None:
                            df = analysis['market_data'][decision['symbol']]
                            decision['price'] = df['Close'].iloc[-1] if not df.empty else 0.0
        
        logger.info(f"  ðŸŽ¯ Decision: {decision['action']} {decision['symbol'] or 'N/A'}")
        if decision['action'] != 'HOLD':
            logger.info(f"  ðŸ“Š Shares: {decision['shares']:.4f} @ ${decision['price']:.2f}")
            logger.info(f"  ðŸ’¯ Confidence: {decision['confidence']*100:.1f}%")
        
        return decision
    
    def _calculate_position_size(self, symbol: str, confidence: float, analysis: Dict) -> float:
        """
        Calculate optimal position size based on:
        - Available capital
        - Confidence level
        - Volatility
        - Risk management rules
        """
        # Base allocation: 5-10% of capital per trade
        base_allocation = self.current_capital * 0.05
        
        # Adjust by confidence
        adjusted_allocation = base_allocation * confidence
        
        # Adjust by volatility (reduce size in high vol)
        if symbol in analysis.get('volatility', {}):
            vol = analysis['volatility'][symbol].get('volatility', 0.02)
            if vol > 0.03:
                adjusted_allocation *= 0.5  # Half size in high volatility
        
        # Get current price
        if symbol in analysis.get('market_data', {}):
            df = analysis['market_data'][symbol]
            if not df.empty:
                price = df['Close'].iloc[-1]
                shares = adjusted_allocation / price
                return shares
        
        return 0.0
    
    def execute_trade(self, decision: Dict) -> bool:
        """Execute the trading decision"""
        if decision['action'] == 'HOLD' or decision['shares'] == 0:
            log_ai_activity('trade_execution', 'Trade skipped - HOLD action or zero shares', {
                'action': decision['action'],
                'shares': decision['shares']
            })
            return False
        
        logger.info(f"âš¡ Executing Trade: {decision['action']} {decision['symbol']}")
        log_ai_activity('trade_execution', f'Starting trade execution: {decision["action"]} {decision["symbol"]}', {
            'symbol': decision['symbol'],
            'action': decision['action'],
            'shares': decision['shares'],
            'price': decision['price'],
            'confidence': decision['confidence']
        })
        
        try:
            if decision['action'] == 'BUY':
                # Deduct from capital
                cost = decision['shares'] * decision['price']
                if cost > self.current_capital:
                    logger.warning("Insufficient capital")
                    return False
                
                self.current_capital -= cost
                
                # Add to holdings
                if decision['symbol'] in self.holdings:
                    # Average up
                    existing = self.holdings[decision['symbol']]
                    total_shares = existing['shares'] + decision['shares']
                    total_cost = (existing['avg_price'] * existing['shares']) + cost
                    self.holdings[decision['symbol']] = {
                        'shares': total_shares,
                        'avg_price': total_cost / total_shares,
                        'current_price': decision['price']
                    }
                else:
                    self.holdings[decision['symbol']] = {
                        'shares': decision['shares'],
                        'avg_price': decision['price'],
                        'current_price': decision['price']
                    }
                
                # Log trade
                trade_record = {
                    'timestamp': datetime.now(),
                    'action': 'BUY',
                    'symbol': decision['symbol'],
                    'shares': decision['shares'],
                    'price': decision['price'],
                    'cost': cost,
                    'reasoning': decision['reasoning']
                }
                self.trades.append(trade_record)
                
                # Log to AI activity logger
                log_ai_trade(
                    symbol=decision['symbol'],
                    action='BUY',
                    quantity=decision['shares'],
                    price=decision['price'],
                    pnl=0.0,  # No P&L on buy
                    confidence=decision['confidence'],
                    reasoning=decision['reasoning']
                )
                
                logger.info(f"âœ… BUY executed: {decision['shares']:.4f} shares @ ${decision['price']:.2f}")
                return True
            
            elif decision['action'] == 'SELL':
                if decision['symbol'] not in self.holdings:
                    logger.warning("No holdings to sell")
                    return False
                
                # Add to capital
                proceeds = decision['shares'] * decision['price']
                self.current_capital += proceeds
                
                # Calculate P&L
                holding = self.holdings[decision['symbol']]
                cost_basis = holding['avg_price'] * decision['shares']
                pnl = proceeds - cost_basis
                pnl_pct = (pnl / cost_basis) * 100 if cost_basis > 0 else 0
                
                # Remove from holdings
                holding['shares'] -= decision['shares']
                if holding['shares'] <= 0.0001:  # Essentially zero
                    del self.holdings[decision['symbol']]
                
                # Log trade
                trade_record = {
                    'timestamp': datetime.now(),
                    'action': 'SELL',
                    'symbol': decision['symbol'],
                    'shares': decision['shares'],
                    'price': decision['price'],
                    'proceeds': proceeds,
                    'pnl': pnl,
                    'pnl_pct': pnl_pct,
                    'reasoning': decision['reasoning']
                }
                self.trades.append(trade_record)
                
                # Log to AI activity logger
                log_ai_trade(
                    symbol=decision['symbol'],
                    action='SELL',
                    quantity=decision['shares'],
                    price=decision['price'],
                    pnl=pnl,
                    confidence=decision['confidence'],
                    reasoning=decision['reasoning']
                )
                
                logger.info(f"âœ… SELL executed: {decision['shares']:.4f} shares @ ${decision['price']:.2f}")
                logger.info(f"  ðŸ’° P&L: ${pnl:+.2f} ({pnl_pct:+.2f}%)")
                
                # Learn from the trade
                self._learn_from_trade(pnl, pnl_pct, decision)
                
                return True
        
        except Exception as e:
            logger.error(f"âŒ Trade execution failed: {e}")
            log_ai_activity('error', f'Trade execution failed: {str(e)}', {
                'symbol': decision.get('symbol'),
                'action': decision.get('action'),
                'error_type': type(e).__name__
            })
            return False
    
    def _learn_from_trade(self, pnl: float, pnl_pct: float, decision: Dict):
        """Learn from trade outcome"""
        if pnl > 0:
            # Successful trade - remember the pattern
            self.successful_patterns.append({
                'timestamp': datetime.now(),
                'symbol': decision['symbol'],
                'pnl': pnl,
                'pnl_pct': pnl_pct,
                'reasoning': decision['reasoning'],
                'confidence': decision['confidence']
            })
            logger.info(f"  ðŸ“š Learned: Successful pattern recorded")
        else:
            # Losing trade - analyze mistake
            self.mistakes_log.append({
                'timestamp': datetime.now(),
                'symbol': decision['symbol'],
                'pnl': pnl,
                'pnl_pct': pnl_pct,
                'reasoning': decision['reasoning'],
                'confidence': decision['confidence'],
                'lesson': "Review entry criteria and risk management"
            })
            logger.info(f"  ðŸ“š Learned: Mistake logged for improvement")
    
    def get_portfolio_status(self) -> Dict:
        """Get current portfolio status"""
        total_value = self.current_capital
        invested = 0.0
        unrealized_pnl = 0.0
        
        for symbol, holding in self.holdings.items():
            cost_basis = holding['avg_price'] * holding['shares']
            current_value = holding['current_price'] * holding['shares']
            invested += cost_basis
            unrealized_pnl += (current_value - cost_basis)
            total_value += current_value
        
        realized_pnl = sum(t.get('pnl', 0) for t in self.trades if t['action'] == 'SELL')
        total_pnl = realized_pnl + unrealized_pnl
        total_pnl_pct = (total_pnl / self.initial_capital * 100) if self.initial_capital > 0 else 0
        
        return {
            'cash': self.current_capital,
            'invested': invested,
            'total_value': total_value,
            'realized_pnl': realized_pnl,
            'unrealized_pnl': unrealized_pnl,
            'total_pnl': total_pnl,
            'total_pnl_pct': total_pnl_pct,
            'num_holdings': len(self.holdings),
            'num_trades': len(self.trades)
        }

