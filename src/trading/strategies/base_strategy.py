"""
Base Strategy Class

Provides the foundation for all intraday trading strategies with standardized
interfaces, risk management, and signal generation.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any
import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    EXIT_LONG = "exit_long"
    EXIT_SHORT = "exit_short"


@dataclass
class StrategySignal:
    """Trading signal generated by a strategy"""
    signal_type: SignalType
    symbol: str
    price: float
    timestamp: datetime
    confidence: float  # 0.0 to 1.0
    strategy_name: str

    # Risk parameters
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size_pct: float = 0.10  # 10% default position size

    # Additional metadata
    reason: str = ""
    indicators: Dict[str, float] = field(default_factory=dict)

    def __post_init__(self):
        # Validate confidence
        self.confidence = max(0.0, min(1.0, self.confidence))


@dataclass
class StrategyPerformance:
    """Strategy performance metrics"""
    total_signals: int = 0
    winning_signals: int = 0
    losing_signals: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    avg_profit: float = 0.0
    avg_loss: float = 0.0
    profit_factor: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0


class BaseStrategy(ABC):
    """
    Abstract base class for all intraday trading strategies.

    Features:
    - Standardized signal generation interface
    - Built-in risk management
    - Performance tracking
    - Technical indicator calculations
    """

    def __init__(self, name: str, config: Optional[Dict[str, Any]] = None):
        self.name = name
        self.config = config or {}

        # Default strategy parameters
        self.min_confidence = self.config.get('min_confidence', 0.6)
        self.max_position_size_pct = self.config.get('max_position_size_pct', 0.20)
        self.default_stop_loss_pct = self.config.get('default_stop_loss_pct', 0.02)
        self.default_take_profit_pct = self.config.get('default_take_profit_pct', 0.04)

        # Signal history
        self.signal_history: List[StrategySignal] = []
        self.performance = StrategyPerformance()

        # Market state
        self.current_position: Optional[str] = None  # 'long', 'short', or None

        logger.info(f"Initialized strategy: {self.name}")

    @abstractmethod
    def generate_signal(self, market_data: pd.DataFrame, symbol: str) -> Optional[StrategySignal]:
        """
        Generate trading signal based on market data.

        Args:
            market_data: DataFrame with OHLCV data
            symbol: Stock symbol

        Returns:
            StrategySignal or None if no signal
        """
        pass

    @abstractmethod
    def get_required_lookback(self) -> int:
        """
        Get required number of historical bars for strategy.

        Returns:
            Number of bars required
        """
        pass

    def validate_data(self, market_data: pd.DataFrame) -> bool:
        """Validate that market data has required columns and length"""
        required_columns = ['Open', 'High', 'Low', 'Close', 'Volume']

        # Check columns exist
        for col in required_columns:
            if col not in market_data.columns:
                logger.warning(f"Missing required column: {col}")
                return False

        # Check minimum length
        if len(market_data) < self.get_required_lookback():
            logger.warning(f"Insufficient data: {len(market_data)} < {self.get_required_lookback()}")
            return False

        return True

    def calculate_position_size(self, capital: float, price: float,
                                risk_per_trade: float = 0.02) -> int:
        """
        Calculate position size based on risk management.

        Args:
            capital: Available capital
            price: Current price
            risk_per_trade: Risk per trade as decimal (default 2%)

        Returns:
            Number of shares to trade
        """
        # Risk-based position sizing
        risk_amount = capital * risk_per_trade
        stop_loss_amount = price * self.default_stop_loss_pct

        if stop_loss_amount > 0:
            shares = int(risk_amount / stop_loss_amount)
        else:
            shares = int((capital * self.max_position_size_pct) / price)

        # Ensure minimum 1 share
        return max(1, shares)

    def calculate_stop_loss(self, entry_price: float, side: str,
                           atr: Optional[float] = None) -> float:
        """
        Calculate stop loss price.

        Args:
            entry_price: Entry price
            side: 'long' or 'short'
            atr: Average True Range (optional, for ATR-based stops)

        Returns:
            Stop loss price
        """
        if atr:
            # ATR-based stop loss (2x ATR)
            stop_distance = atr * 2
        else:
            # Percentage-based stop loss
            stop_distance = entry_price * self.default_stop_loss_pct

        if side == 'long':
            return entry_price - stop_distance
        else:  # short
            return entry_price + stop_distance

    def calculate_take_profit(self, entry_price: float, side: str,
                             atr: Optional[float] = None) -> float:
        """
        Calculate take profit price.

        Args:
            entry_price: Entry price
            side: 'long' or 'short'
            atr: Average True Range (optional, for ATR-based targets)

        Returns:
            Take profit price
        """
        if atr:
            # ATR-based take profit (4x ATR)
            profit_distance = atr * 4
        else:
            # Percentage-based take profit
            profit_distance = entry_price * self.default_take_profit_pct

        if side == 'long':
            return entry_price + profit_distance
        else:  # short
            return entry_price - profit_distance

    # ==========================================================================
    # Technical Indicators
    # ==========================================================================

    def calculate_sma(self, data: pd.Series, period: int) -> pd.Series:
        """Calculate Simple Moving Average"""
        return data.rolling(window=period).mean()

    def calculate_ema(self, data: pd.Series, period: int) -> pd.Series:
        """Calculate Exponential Moving Average"""
        return data.ewm(span=period, adjust=False).mean()

    def calculate_rsi(self, data: pd.Series, period: int = 14) -> pd.Series:
        """Calculate Relative Strength Index"""
        delta = data.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def calculate_macd(self, data: pd.Series, fast: int = 12, slow: int = 26,
                       signal: int = 9) -> Dict[str, pd.Series]:
        """Calculate MACD"""
        ema_fast = self.calculate_ema(data, fast)
        ema_slow = self.calculate_ema(data, slow)

        macd_line = ema_fast - ema_slow
        signal_line = self.calculate_ema(macd_line, signal)
        histogram = macd_line - signal_line

        return {
            'macd': macd_line,
            'signal': signal_line,
            'histogram': histogram
        }

    def calculate_bollinger_bands(self, data: pd.Series, period: int = 20,
                                  std_dev: float = 2.0) -> Dict[str, pd.Series]:
        """Calculate Bollinger Bands"""
        middle = self.calculate_sma(data, period)
        std = data.rolling(window=period).std()

        upper = middle + (std * std_dev)
        lower = middle - (std * std_dev)

        return {
            'upper': upper,
            'middle': middle,
            'lower': lower,
            'bandwidth': (upper - lower) / middle
        }

    def calculate_atr(self, high: pd.Series, low: pd.Series, close: pd.Series,
                      period: int = 14) -> pd.Series:
        """Calculate Average True Range"""
        tr1 = high - low
        tr2 = abs(high - close.shift(1))
        tr3 = abs(low - close.shift(1))

        true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = true_range.rolling(window=period).mean()

        return atr

    def calculate_vwap(self, high: pd.Series, low: pd.Series, close: pd.Series,
                       volume: pd.Series) -> pd.Series:
        """Calculate Volume Weighted Average Price"""
        typical_price = (high + low + close) / 3
        cumulative_tpv = (typical_price * volume).cumsum()
        cumulative_volume = volume.cumsum()

        vwap = cumulative_tpv / cumulative_volume
        return vwap

    def calculate_momentum(self, data: pd.Series, period: int = 14) -> pd.Series:
        """Calculate Price Momentum"""
        return data.diff(period)

    def calculate_stochastic(self, high: pd.Series, low: pd.Series, close: pd.Series,
                            k_period: int = 14, d_period: int = 3) -> Dict[str, pd.Series]:
        """Calculate Stochastic Oscillator"""
        lowest_low = low.rolling(window=k_period).min()
        highest_high = high.rolling(window=k_period).max()

        k = 100 * (close - lowest_low) / (highest_high - lowest_low)
        d = k.rolling(window=d_period).mean()

        return {'k': k, 'd': d}

    def calculate_obv(self, close: pd.Series, volume: pd.Series) -> pd.Series:
        """Calculate On-Balance Volume"""
        direction = np.where(close > close.shift(1), 1,
                    np.where(close < close.shift(1), -1, 0))
        return (volume * direction).cumsum()

    # ==========================================================================
    # Performance Tracking
    # ==========================================================================

    def record_signal(self, signal: StrategySignal):
        """Record a generated signal"""
        self.signal_history.append(signal)
        self.performance.total_signals += 1

    def record_outcome(self, signal: StrategySignal, exit_price: float):
        """Record the outcome of a signal"""
        if signal.signal_type == SignalType.BUY:
            pnl = exit_price - signal.price
        elif signal.signal_type == SignalType.SELL:
            pnl = signal.price - exit_price
        else:
            return

        if pnl > 0:
            self.performance.winning_signals += 1
        else:
            self.performance.losing_signals += 1

        self.performance.total_pnl += pnl
        self._update_performance_metrics()

    def _update_performance_metrics(self):
        """Update performance metrics"""
        total = self.performance.winning_signals + self.performance.losing_signals

        if total > 0:
            self.performance.win_rate = self.performance.winning_signals / total

    def get_performance_summary(self) -> Dict[str, Any]:
        """Get performance summary"""
        return {
            'strategy_name': self.name,
            'total_signals': self.performance.total_signals,
            'winning_signals': self.performance.winning_signals,
            'losing_signals': self.performance.losing_signals,
            'win_rate': self.performance.win_rate,
            'total_pnl': self.performance.total_pnl
        }

    def __repr__(self) -> str:
        return f"<Strategy: {self.name}>"
