"""
Advanced Vulnerability Scanner

This module implements a comprehensive vulnerability scanning system with
automated detection, classification, and remediation guidance for various
types of security vulnerabilities.

Author: AI Trading System
Version: 1.0.0
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import logging
from enum import Enum
import json
import sqlite3
from pathlib import Path
import subprocess
import socket
import ssl
import requests
import hashlib
import base64
import re
import urllib.parse
import warnings
warnings.filterwarnings('ignore')

logger = logging.getLogger(__name__)

class ScanType(Enum):
    """Types of vulnerability scans."""
    NETWORK_SCAN = "NETWORK_SCAN"
    WEB_APPLICATION_SCAN = "WEB_APPLICATION_SCAN"
    API_SECURITY_SCAN = "API_SECURITY_SCAN"
    SSL_TLS_SCAN = "SSL_TLS_SCAN"
    DATABASE_SCAN = "DATABASE_SCAN"
    CONFIGURATION_SCAN = "CONFIGURATION_SCAN"
    CODE_ANALYSIS = "CODE_ANALYSIS"
    DEPENDENCY_SCAN = "DEPENDENCY_SCAN"
    CONTAINER_SCAN = "CONTAINER_SCAN"
    CLOUD_SCAN = "CLOUD_SCAN"

class SeverityLevel(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFORMATIONAL = "INFORMATIONAL"

class ScanStatus(Enum):
    """Scan status."""
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"

@dataclass
class Vulnerability:
    """Vulnerability definition."""
    vuln_id: str
    name: str
    description: str
    severity: SeverityLevel
    category: str
    cve_id: Optional[str]
    cvss_score: Optional[float]
    affected_components: List[str]
    attack_vector: str
    impact: str
    remediation: str
    references: List[str]
    proof_of_concept: Optional[str]
    discovered_at: datetime
    verified: bool = False
    exploited: bool = False
    false_positive: bool = False
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class ScanResult:
    """Vulnerability scan result."""
    scan_id: str
    target: str
    scan_type: ScanType
    start_time: datetime
    end_time: Optional[datetime]
    status: ScanStatus
    vulnerabilities_found: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    info_count: int
    scan_results: List[Vulnerability]
    scan_config: Dict[str, Any]
    created_at: datetime = field(default_factory=datetime.now)

class VulnerabilityScanner:
    """
    Advanced vulnerability scanner with comprehensive detection capabilities.
    
    Features:
    - Multi-type vulnerability scanning
    - Automated vulnerability detection
    - CVSS scoring and classification
    - Remediation guidance
    - False positive detection
    - Scan result management
    """
    
    def __init__(self, db_path: str = "data/vulnerability_scanner.db"):
        """
        Initialize vulnerability scanner.
        
        Args:
            db_path: Path to vulnerability scanner database
        """
        self.db_path = db_path
        self.scan_results: List[ScanResult] = []
        self.vulnerability_signatures: Dict[str, Dict[str, Any]] = {}
        
        # Scan configurations
        self.scan_configs = {
            ScanType.NETWORK_SCAN: {
                'ports': [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306, 1433],
                'timeout': 5,
                'threads': 10
            },
            ScanType.WEB_APPLICATION_SCAN: {
                'paths': ['/admin', '/login', '/api', '/.env', '/config', '/backup'],
                'timeout': 10,
                'user_agent': 'VulnerabilityScanner/1.0'
            },
            ScanType.API_SECURITY_SCAN: {
                'endpoints': ['/api/v1', '/api/v2', '/graphql', '/rest'],
                'methods': ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
                'timeout': 10
            },
            ScanType.SSL_TLS_SCAN: {
                'protocols': ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1', 'TLSv1.2', 'TLSv1.3'],
                'ciphers': True,
                'certificate_check': True
            }
        }
        
        # Initialize database
        self._init_database()
        
        # Load vulnerability signatures
        self._load_vulnerability_signatures()
        
        logger.info("Advanced Vulnerability Scanner initialized")
    
    def _init_database(self) -> None:
        """Initialize vulnerability scanner database schema."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create scan results table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS scan_results (
                scan_id TEXT PRIMARY KEY,
                target TEXT NOT NULL,
                scan_type TEXT NOT NULL,
                start_time TEXT NOT NULL,
                end_time TEXT,
                status TEXT NOT NULL,
                vulnerabilities_found INTEGER,
                critical_count INTEGER,
                high_count INTEGER,
                medium_count INTEGER,
                low_count INTEGER,
                info_count INTEGER,
                scan_results TEXT,
                scan_config TEXT,
                created_at TEXT NOT NULL
            )
        """)
        
        # Create vulnerabilities table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                vuln_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                severity TEXT NOT NULL,
                category TEXT,
                cve_id TEXT,
                cvss_score REAL,
                affected_components TEXT,
                attack_vector TEXT,
                impact TEXT,
                remediation TEXT,
                references TEXT,
                proof_of_concept TEXT,
                discovered_at TEXT,
                verified INTEGER,
                exploited INTEGER,
                false_positive INTEGER,
                created_at TEXT NOT NULL
            )
        """)
        
        # Create vulnerability signatures table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS vulnerability_signatures (
                signature_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                pattern TEXT NOT NULL,
                severity TEXT NOT NULL,
                category TEXT,
                description TEXT,
                remediation TEXT,
                created_at TEXT NOT NULL
            )
        """)
        
        conn.commit()
        conn.close()
    
    def _load_vulnerability_signatures(self) -> None:
        """Load vulnerability detection signatures."""
        signatures = [
            {
                'signature_id': 'SIG_001',
                'name': 'SQL Injection',
                'pattern': r'(union\s+select|insert\s+into|delete\s+from|update\s+set|drop\s+table)',
                'severity': SeverityLevel.HIGH,
                'category': 'Injection',
                'description': 'SQL injection vulnerability detected',
                'remediation': 'Use parameterized queries and input validation'
            },
            {
                'signature_id': 'SIG_002',
                'name': 'Cross-Site Scripting',
                'pattern': r'<script[^>]*>.*?</script>|<img[^>]*onerror|<iframe[^>]*>',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Cross-Site Scripting',
                'description': 'XSS vulnerability detected',
                'remediation': 'Implement output encoding and CSP headers'
            },
            {
                'signature_id': 'SIG_003',
                'name': 'Directory Traversal',
                'pattern': r'\.\./|\.\.\\|%2e%2e%2f|%2e%2e%5c',
                'severity': SeverityLevel.HIGH,
                'category': 'Path Traversal',
                'description': 'Directory traversal vulnerability detected',
                'remediation': 'Validate and sanitize file paths'
            },
            {
                'signature_id': 'SIG_004',
                'name': 'Command Injection',
                'pattern': r'[;&|`$(){}]',
                'severity': SeverityLevel.CRITICAL,
                'category': 'Command Injection',
                'description': 'Command injection vulnerability detected',
                'remediation': 'Avoid system commands, use safe alternatives'
            },
            {
                'signature_id': 'SIG_005',
                'name': 'Weak Authentication',
                'pattern': r'(password|passwd|pwd)\s*=\s*["\']?[^"\']{1,7}["\']?',
                'severity': SeverityLevel.HIGH,
                'category': 'Authentication',
                'description': 'Weak authentication detected',
                'remediation': 'Implement strong password policies'
            },
            {
                'signature_id': 'SIG_006',
                'name': 'Hardcoded Credentials',
                'pattern': r'(password|passwd|pwd|secret|key)\s*=\s*["\'][^"\']+["\']',
                'severity': SeverityLevel.CRITICAL,
                'category': 'Information Disclosure',
                'description': 'Hardcoded credentials detected',
                'remediation': 'Use environment variables or secure key management'
            },
            {
                'signature_id': 'SIG_007',
                'name': 'Insecure Random',
                'pattern': r'Math\.random\(\)|new\s+Random\(\)|rand\(\)',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Cryptography',
                'description': 'Insecure random number generation detected',
                'remediation': 'Use cryptographically secure random generators'
            },
            {
                'signature_id': 'SIG_008',
                'name': 'Weak Encryption',
                'pattern': r'(DES|MD5|SHA1|RC4|WEP)',
                'severity': SeverityLevel.HIGH,
                'category': 'Cryptography',
                'description': 'Weak encryption algorithm detected',
                'remediation': 'Use strong encryption algorithms (AES, SHA-256)'
            }
        ]
        
        for sig in signatures:
            self.vulnerability_signatures[sig['signature_id']] = sig
    
    def run_scan(self, target: str, scan_type: ScanType, 
                 custom_config: Dict[str, Any] = None) -> str:
        """
        Run a vulnerability scan on a target.
        
        Args:
            target: Target to scan
            scan_type: Type of scan to run
            custom_config: Custom scan configuration
            
        Returns:
            Scan ID
        """
        scan_id = f"SCAN_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Get scan configuration
        config = self.scan_configs.get(scan_type, {})
        if custom_config:
            config.update(custom_config)
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=target,
            scan_type=scan_type,
            start_time=datetime.now(),
            end_time=None,
            status=ScanStatus.RUNNING,
            vulnerabilities_found=0,
            critical_count=0,
            high_count=0,
            medium_count=0,
            low_count=0,
            info_count=0,
            scan_results=[],
            scan_config=config
        )
        
        try:
            # Run the appropriate scan based on type
            vulnerabilities = []
            
            if scan_type == ScanType.NETWORK_SCAN:
                vulnerabilities = self._run_network_scan(target, config)
            elif scan_type == ScanType.WEB_APPLICATION_SCAN:
                vulnerabilities = self._run_web_application_scan(target, config)
            elif scan_type == ScanType.API_SECURITY_SCAN:
                vulnerabilities = self._run_api_security_scan(target, config)
            elif scan_type == ScanType.SSL_TLS_SCAN:
                vulnerabilities = self._run_ssl_tls_scan(target, config)
            elif scan_type == ScanType.DATABASE_SCAN:
                vulnerabilities = self._run_database_scan(target, config)
            elif scan_type == ScanType.CONFIGURATION_SCAN:
                vulnerabilities = self._run_configuration_scan(target, config)
            elif scan_type == ScanType.CODE_ANALYSIS:
                vulnerabilities = self._run_code_analysis_scan(target, config)
            elif scan_type == ScanType.DEPENDENCY_SCAN:
                vulnerabilities = self._run_dependency_scan(target, config)
            elif scan_type == ScanType.CONTAINER_SCAN:
                vulnerabilities = self._run_container_scan(target, config)
            elif scan_type == ScanType.CLOUD_SCAN:
                vulnerabilities = self._run_cloud_scan(target, config)
            
            # Update scan results
            scan_result.scan_results = vulnerabilities
            scan_result.vulnerabilities_found = len(vulnerabilities)
            scan_result.critical_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.CRITICAL])
            scan_result.high_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.HIGH])
            scan_result.medium_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.MEDIUM])
            scan_result.low_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.LOW])
            scan_result.info_count = len([v for v in vulnerabilities if v.severity == SeverityLevel.INFORMATIONAL])
            scan_result.end_time = datetime.now()
            scan_result.status = ScanStatus.COMPLETED
            
        except Exception as e:
            logger.error(f"Scan failed: {e}")
            scan_result.status = ScanStatus.FAILED
            scan_result.end_time = datetime.now()
        
        # Store scan results
        self.scan_results.append(scan_result)
        self._store_scan_result(scan_result)
        
        # Store individual vulnerabilities
        for vuln in scan_result.scan_results:
            self._store_vulnerability(vuln)
        
        logger.info(f"Completed {scan_type.value} scan: {scan_id} - Found {scan_result.vulnerabilities_found} vulnerabilities")
        return scan_id
    
    def _run_network_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run network vulnerability scan."""
        vulnerabilities = []
        
        try:
            ports = config.get('ports', [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306, 1433])
            timeout = config.get('timeout', 5)
            
            for port in ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    result = sock.connect_ex((target, port))
                    sock.close()
                    
                    if result == 0:
                        # Port is open - check for vulnerabilities
                        vuln = self._check_port_vulnerabilities(target, port)
                        if vuln:
                            vulnerabilities.append(vuln)
                
                except Exception:
                    continue
        
        except Exception as e:
            logger.error(f"Network scan error: {e}")
        
        return vulnerabilities
    
    def _check_port_vulnerabilities(self, target: str, port: int) -> Optional[Vulnerability]:
        """Check for vulnerabilities on a specific port."""
        port_vulns = {
            21: {
                'name': 'FTP Service',
                'description': 'FTP service may allow anonymous access or weak authentication',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Network Service',
                'remediation': 'Disable anonymous access, use strong authentication'
            },
            22: {
                'name': 'SSH Service',
                'description': 'SSH service may have weak authentication or configuration issues',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Network Service',
                'remediation': 'Use key-based authentication, disable root login'
            },
            23: {
                'name': 'Telnet Service',
                'description': 'Telnet service transmits data in plaintext',
                'severity': SeverityLevel.HIGH,
                'category': 'Network Service',
                'remediation': 'Replace with SSH or other encrypted protocol'
            },
            25: {
                'name': 'SMTP Service',
                'description': 'SMTP service may allow open relay or have configuration issues',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Network Service',
                'remediation': 'Configure proper relay restrictions'
            },
            80: {
                'name': 'HTTP Service',
                'description': 'HTTP service may be vulnerable to various web attacks',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Web Service',
                'remediation': 'Use HTTPS, implement security headers'
            },
            443: {
                'name': 'HTTPS Service',
                'description': 'HTTPS service may have SSL/TLS vulnerabilities',
                'severity': SeverityLevel.MEDIUM,
                'category': 'Web Service',
                'remediation': 'Use strong SSL/TLS configuration'
            },
            3389: {
                'name': 'RDP Service',
                'description': 'RDP service may allow brute force attacks',
                'severity': SeverityLevel.HIGH,
                'category': 'Remote Access',
                'remediation': 'Use strong authentication, implement account lockout'
            },
            5432: {
                'name': 'PostgreSQL Service',
                'description': 'PostgreSQL service may have default credentials or weak configuration',
                'severity': SeverityLevel.HIGH,
                'category': 'Database Service',
                'remediation': 'Change default credentials, restrict network access'
            },
            3306: {
                'name': 'MySQL Service',
                'description': 'MySQL service may have default credentials or weak configuration',
                'severity': SeverityLevel.HIGH,
                'category': 'Database Service',
                'remediation': 'Change default credentials, restrict network access'
            },
            1433: {
                'name': 'SQL Server Service',
                'description': 'SQL Server service may have default credentials or weak configuration',
                'severity': SeverityLevel.HIGH,
                'category': 'Database Service',
                'remediation': 'Change default credentials, restrict network access'
            }
        }
        
        if port in port_vulns:
            vuln_info = port_vulns[port]
            return Vulnerability(
                vuln_id=f"NET_{port}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                name=vuln_info['name'],
                description=vuln_info['description'],
                severity=vuln_info['severity'],
                category=vuln_info['category'],
                cve_id=None,
                cvss_score=self._calculate_cvss_score(vuln_info['severity']),
                affected_components=[f"{target}:{port}"],
                attack_vector="Network",
                impact="Potential unauthorized access or information disclosure",
                remediation=vuln_info['remediation'],
                references=[],
                proof_of_concept=f"Port {port} is open and accessible",
                discovered_at=datetime.now()
            )
        
        return None
    
    def _run_web_application_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run web application vulnerability scan."""
        vulnerabilities = []
        
        try:
            paths = config.get('paths', ['/admin', '/login', '/api', '/.env', '/config', '/backup'])
            timeout = config.get('timeout', 10)
            user_agent = config.get('user_agent', 'VulnerabilityScanner/1.0')
            
            url = f"http://{target}" if not target.startswith(('http://', 'https://')) else target
            
            # Test for common vulnerabilities
            for path in paths:
                try:
                    response = requests.get(
                        f"{url}{path}", 
                        timeout=timeout, 
                        allow_redirects=False,
                        headers={'User-Agent': user_agent}
                    )
                    
                    if response.status_code == 200:
                        # Check for information disclosure
                        vuln = Vulnerability(
                            vuln_id=f"WEB_{path.replace('/', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                            name=f"Information Disclosure: {path}",
                            description=f"Path {path} is accessible and may expose sensitive information",
                            severity=SeverityLevel.MEDIUM,
                            category="Information Disclosure",
                            cve_id="CWE-200",
                            cvss_score=5.3,
                            affected_components=[f"{url}{path}"],
                            attack_vector="Network",
                            impact="Information disclosure, potential unauthorized access",
                            remediation="Restrict access to sensitive paths, implement proper authentication",
                            references=["https://owasp.org/www-community/controls/Protect_Data"],
                            proof_of_concept=f"GET {url}{path} returns 200 OK",
                            discovered_at=datetime.now()
                        )
                        vulnerabilities.append(vuln)
                
                except Exception:
                    continue
            
            # Test for SQL injection
            sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
            for payload in sql_payloads:
                try:
                    response = requests.get(
                        f"{url}/search?q={urllib.parse.quote(payload)}",
                        timeout=timeout,
                        headers={'User-Agent': user_agent}
                    )
                    
                    if self._detect_sql_injection(response.text):
                        vuln = Vulnerability(
                            vuln_id=f"SQL_INJ_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                            name="SQL Injection",
                            description="SQL injection vulnerability detected in search parameter",
                            severity=SeverityLevel.HIGH,
                            category="Injection",
                            cve_id="CWE-89",
                            cvss_score=8.8,
                            affected_components=[f"{url}/search"],
                            attack_vector="Network",
                            impact="Data breach, unauthorized access, data manipulation",
                            remediation="Use parameterized queries, input validation, WAF",
                            references=["https://owasp.org/www-community/attacks/SQL_Injection"],
                            proof_of_concept=f"Payload: {payload}",
                            discovered_at=datetime.now()
                        )
                        vulnerabilities.append(vuln)
                        break
                
                except Exception:
                    continue
        
        except Exception as e:
            logger.error(f"Web application scan error: {e}")
        
        return vulnerabilities
    
    def _detect_sql_injection(self, response_text: str) -> bool:
        """Detect SQL injection based on response."""
        sql_errors = [
            "mysql_fetch_array",
            "ORA-01756",
            "Microsoft OLE DB Provider",
            "SQLServer JDBC Driver",
            "PostgreSQL query failed",
            "Warning: mysql_",
            "valid MySQL result",
            "MySqlClient.",
            "SQL syntax",
            "mysql_num_rows",
            "mysql_numrows",
            "mysql_query",
            "mysql_fetch_assoc",
            "mysql_fetch_row",
            "mysql_fetch_object",
            "mysql_fetch_array"
        ]
        
        response_lower = response_text.lower()
        return any(error.lower() in response_lower for error in sql_errors)
    
    def _run_api_security_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run API security vulnerability scan."""
        vulnerabilities = []
        
        try:
            endpoints = config.get('endpoints', ['/api/v1', '/api/v2', '/graphql', '/rest'])
            methods = config.get('methods', ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'])
            timeout = config.get('timeout', 10)
            
            base_url = f"http://{target}" if not target.startswith(('http://', 'https://')) else target
            
            for endpoint in endpoints:
                for method in methods:
                    try:
                        response = requests.request(
                            method,
                            f"{base_url}{endpoint}",
                            timeout=timeout,
                            allow_redirects=False
                        )
                        
                        # Check for authentication bypass
                        if response.status_code == 200:
                            vuln = Vulnerability(
                                vuln_id=f"API_AUTH_{method}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                                name="API Authentication Bypass",
                                description=f"API endpoint {endpoint} is accessible without authentication using {method} method",
                                severity=SeverityLevel.HIGH,
                                category="Authentication",
                                cve_id="CWE-287",
                                cvss_score=7.5,
                                affected_components=[f"{base_url}{endpoint}"],
                                attack_vector="Network",
                                impact="Unauthorized access to API endpoints",
                                remediation="Implement proper authentication and authorization",
                                references=["https://owasp.org/www-community/controls/Authentication"],
                                proof_of_concept=f"{method} {base_url}{endpoint} returns 200 OK",
                                discovered_at=datetime.now()
                            )
                            vulnerabilities.append(vuln)
                    
                    except Exception:
                        continue
        
        except Exception as e:
            logger.error(f"API security scan error: {e}")
        
        return vulnerabilities
    
    def _run_ssl_tls_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run SSL/TLS vulnerability scan."""
        vulnerabilities = []
        
        try:
            # Extract hostname and port from target
            if ':' in target:
                hostname, port = target.split(':')
                port = int(port)
            else:
                hostname = target
                port = 443
            
            # Test SSL/TLS configuration
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    version = ssock.version()
            
            # Check for weak SSL/TLS versions
            weak_versions = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']
            if version in weak_versions:
                vuln = Vulnerability(
                    vuln_id=f"SSL_VERSION_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    name="Weak SSL/TLS Version",
                    description=f"Server supports weak SSL/TLS version: {version}",
                    severity=SeverityLevel.HIGH,
                    category="Cryptography",
                    cve_id="CVE-2014-3566",
                    cvss_score=7.4,
                    affected_components=[f"{hostname}:{port}"],
                    attack_vector="Network",
                    impact="Man-in-the-middle attacks, data interception",
                    remediation="Disable weak SSL/TLS versions, use TLS 1.2 or higher",
                    references=["https://tools.ietf.org/html/rfc7568"],
                    proof_of_concept=f"SSL/TLS version: {version}",
                    discovered_at=datetime.now()
                )
                vulnerabilities.append(vuln)
            
            # Check certificate validity
            if cert:
                not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                if not_after < datetime.now() + timedelta(days=30):
                    vuln = Vulnerability(
                        vuln_id=f"SSL_CERT_EXPIRY_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                        name="SSL Certificate Expiring Soon",
                        description=f"SSL certificate expires on {cert['notAfter']}",
                        severity=SeverityLevel.MEDIUM,
                        category="Cryptography",
                        cve_id=None,
                        cvss_score=4.3,
                        affected_components=[f"{hostname}:{port}"],
                        attack_vector="Network",
                        impact="Service disruption, potential security issues",
                        remediation="Renew SSL certificate before expiration",
                        references=[],
                        proof_of_concept=f"Certificate expires: {cert['notAfter']}",
                        discovered_at=datetime.now()
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"SSL/TLS scan error: {e}")
        
        return vulnerabilities
    
    def _run_database_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run database vulnerability scan."""
        vulnerabilities = []
        
        # This would typically involve connecting to databases and checking configurations
        # For now, we'll return a placeholder
        return vulnerabilities
    
    def _run_configuration_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run configuration vulnerability scan."""
        vulnerabilities = []
        
        # This would typically involve checking system configurations
        # For now, we'll return a placeholder
        return vulnerabilities
    
    def _run_code_analysis_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run code analysis vulnerability scan."""
        vulnerabilities = []
        
        try:
            # This would typically involve static code analysis
            # For now, we'll do basic pattern matching on files
            if target.endswith(('.py', '.js', '.java', '.php', '.cpp', '.c')):
                with open(target, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Check for vulnerability patterns
                for sig_id, signature in self.vulnerability_signatures.items():
                    pattern = signature['pattern']
                    if re.search(pattern, content, re.IGNORECASE):
                        vuln = Vulnerability(
                            vuln_id=f"CODE_{sig_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                            name=signature['name'],
                            description=signature['description'],
                            severity=signature['severity'],
                            category=signature['category'],
                            cve_id=None,
                            cvss_score=self._calculate_cvss_score(signature['severity']),
                            affected_components=[target],
                            attack_vector="Local",
                            impact="Code vulnerability may lead to security issues",
                            remediation=signature['remediation'],
                            references=[],
                            proof_of_concept=f"Pattern found: {pattern}",
                            discovered_at=datetime.now()
                        )
                        vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Code analysis scan error: {e}")
        
        return vulnerabilities
    
    def _run_dependency_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run dependency vulnerability scan."""
        vulnerabilities = []
        
        # This would typically involve checking for known vulnerabilities in dependencies
        # For now, we'll return a placeholder
        return vulnerabilities
    
    def _run_container_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run container vulnerability scan."""
        vulnerabilities = []
        
        # This would typically involve scanning container images
        # For now, we'll return a placeholder
        return vulnerabilities
    
    def _run_cloud_scan(self, target: str, config: Dict[str, Any]) -> List[Vulnerability]:
        """Run cloud vulnerability scan."""
        vulnerabilities = []
        
        # This would typically involve checking cloud configurations
        # For now, we'll return a placeholder
        return vulnerabilities
    
    def _calculate_cvss_score(self, severity: SeverityLevel) -> float:
        """Calculate CVSS score based on severity."""
        severity_scores = {
            SeverityLevel.CRITICAL: 9.0,
            SeverityLevel.HIGH: 7.0,
            SeverityLevel.MEDIUM: 5.0,
            SeverityLevel.LOW: 3.0,
            SeverityLevel.INFORMATIONAL: 1.0
        }
        return severity_scores.get(severity, 5.0)
    
    def _store_scan_result(self, scan_result: ScanResult) -> None:
        """Store scan result in database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO scan_results 
            (scan_id, target, scan_type, start_time, end_time, status, vulnerabilities_found,
             critical_count, high_count, medium_count, low_count, info_count, scan_results, scan_config, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            scan_result.scan_id, scan_result.target, scan_result.scan_type.value,
            scan_result.start_time.isoformat(), scan_result.end_time.isoformat() if scan_result.end_time else None,
            scan_result.status.value, scan_result.vulnerabilities_found, scan_result.critical_count,
            scan_result.high_count, scan_result.medium_count, scan_result.low_count,
            scan_result.info_count, json.dumps([v.__dict__ for v in scan_result.scan_results]),
            json.dumps(scan_result.scan_config), scan_result.created_at.isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def _store_vulnerability(self, vulnerability: Vulnerability) -> None:
        """Store vulnerability in database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO vulnerabilities 
            (vuln_id, name, description, severity, category, cve_id, cvss_score,
             affected_components, attack_vector, impact, remediation, references,
             proof_of_concept, discovered_at, verified, exploited, false_positive, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            vulnerability.vuln_id, vulnerability.name, vulnerability.description,
            vulnerability.severity.value, vulnerability.category, vulnerability.cve_id,
            vulnerability.cvss_score, json.dumps(vulnerability.affected_components),
            vulnerability.attack_vector, vulnerability.impact, vulnerability.remediation,
            json.dumps(vulnerability.references), vulnerability.proof_of_concept,
            vulnerability.discovered_at.isoformat(), vulnerability.verified,
            vulnerability.exploited, vulnerability.false_positive, vulnerability.created_at.isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def get_scan_results(self, scan_id: str = None, target: str = None, 
                        scan_type: ScanType = None) -> List[ScanResult]:
        """
        Get scan results with optional filters.
        
        Args:
            scan_id: Filter by scan ID
            target: Filter by target
            scan_type: Filter by scan type
            
        Returns:
            List of matching scan results
        """
        results = self.scan_results.copy()
        
        if scan_id:
            results = [r for r in results if r.scan_id == scan_id]
        
        if target:
            results = [r for r in results if r.target == target]
        
        if scan_type:
            results = [r for r in results if r.scan_type == scan_type]
        
        return results
    
    def get_vulnerabilities(self, severity: SeverityLevel = None, 
                           category: str = None, verified: bool = None) -> List[Vulnerability]:
        """
        Get vulnerabilities with optional filters.
        
        Args:
            severity: Filter by severity
            category: Filter by category
            verified: Filter by verification status
            
        Returns:
            List of matching vulnerabilities
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        if severity:
            query += " AND severity = ?"
            params.append(severity.value)
        
        if category:
            query += " AND category = ?"
            params.append(category)
        
        if verified is not None:
            query += " AND verified = ?"
            params.append(1 if verified else 0)
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()
        
        # Convert rows to Vulnerability objects
        vulnerabilities = []
        for row in rows:
            vuln = Vulnerability(
                vuln_id=row[0],
                name=row[1],
                description=row[2],
                severity=SeverityLevel(row[3]),
                category=row[4],
                cve_id=row[5],
                cvss_score=row[6],
                affected_components=json.loads(row[7]) if row[7] else [],
                attack_vector=row[8],
                impact=row[9],
                remediation=row[10],
                references=json.loads(row[11]) if row[11] else [],
                proof_of_concept=row[12],
                discovered_at=datetime.fromisoformat(row[13]),
                verified=bool(row[14]),
                exploited=bool(row[15]),
                false_positive=bool(row[16]),
                created_at=datetime.fromisoformat(row[17])
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def mark_vulnerability_verified(self, vuln_id: str, verified: bool = True) -> bool:
        """
        Mark a vulnerability as verified or not.
        
        Args:
            vuln_id: Vulnerability ID
            verified: Verification status
            
        Returns:
            True if updated successfully
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE vulnerabilities
            SET verified = ?
            WHERE vuln_id = ?
        """, (1 if verified else 0, vuln_id))
        
        updated = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return updated
    
    def mark_vulnerability_false_positive(self, vuln_id: str, false_positive: bool = True) -> bool:
        """
        Mark a vulnerability as false positive or not.
        
        Args:
            vuln_id: Vulnerability ID
            false_positive: False positive status
            
        Returns:
            True if updated successfully
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE vulnerabilities
            SET false_positive = ?
            WHERE vuln_id = ?
        """, (1 if false_positive else 0, vuln_id))
        
        updated = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return updated
    
    def generate_vulnerability_report(self, scan_id: str = None, 
                                    start_date: datetime = None, 
                                    end_date: datetime = None) -> Dict[str, Any]:
        """
        Generate vulnerability report.
        
        Args:
            scan_id: Specific scan ID
            start_date: Start date filter
            end_date: End date filter
            
        Returns:
            Vulnerability report dictionary
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get vulnerability statistics
        query = "SELECT severity, COUNT(*) as count FROM vulnerabilities WHERE 1=1"
        params = []
        
        if scan_id:
            # This would require joining with scan_results table
            pass
        
        if start_date:
            query += " AND discovered_at >= ?"
            params.append(start_date.isoformat())
        
        if end_date:
            query += " AND discovered_at <= ?"
            params.append(end_date.isoformat())
        
        query += " GROUP BY severity"
        
        cursor.execute(query, params)
        severity_counts = dict(cursor.fetchall())
        
        # Get category breakdown
        cursor.execute("""
            SELECT category, COUNT(*) as count
            FROM vulnerabilities
            GROUP BY category
            ORDER BY count DESC
        """)
        category_counts = dict(cursor.fetchall())
        
        # Get top vulnerabilities
        cursor.execute("""
            SELECT name, COUNT(*) as count
            FROM vulnerabilities
            GROUP BY name
            ORDER BY count DESC
            LIMIT 10
        """)
        top_vulnerabilities = dict(cursor.fetchall())
        
        conn.close()
        
        return {
            'summary': {
                'total_vulnerabilities': sum(severity_counts.values()),
                'critical_vulnerabilities': severity_counts.get('CRITICAL', 0),
                'high_vulnerabilities': severity_counts.get('HIGH', 0),
                'medium_vulnerabilities': severity_counts.get('MEDIUM', 0),
                'low_vulnerabilities': severity_counts.get('LOW', 0),
                'info_vulnerabilities': severity_counts.get('INFORMATIONAL', 0)
            },
            'severity_breakdown': severity_counts,
            'category_breakdown': category_counts,
            'top_vulnerabilities': top_vulnerabilities,
            'period': {
                'start_date': start_date.isoformat() if start_date else None,
                'end_date': end_date.isoformat() if end_date else None
            },
            'generated_at': datetime.now().isoformat()
        }
