                
                logger.info("  ðŸŒ Fetching macro data...")
                macro = self.data_pipeline.fetch_macro_data()
                analysis['macro_indicators'] = macro
                
                logger.info("  Fetching options data...")
                options = self.data_pipeline.fetch_options_data(self.symbols[:5])
                analysis['options_flow'] = options
            except Exception as e:
                logger.error(f"âŒ Data collection failed: {e}")
        
        # 2. Event awareness
        if self.event_calendar:
            try:
                logger.info("  ðŸ“… Checking events...")
                upcoming = self.event_calendar.get_upcoming_events(days=1)
                analysis['events'] = upcoming
            except Exception as e:
                logger.error(f"âŒ Event check failed: {e}")
        
        # 3. Volatility detection
        if self.volatility_detector and analysis['market_data']:
            try:
                logger.info("  ðŸ“Š Detecting volatility...")
                for symbol, df in analysis['market_data'].items():
                    vol_metrics = self.volatility_detector.detect_volatility(df)
                    analysis['volatility'][symbol] = vol_metrics
            except Exception as e:
                logger.error(f"âŒ Volatility detection failed: {e}")
        
        # 4. Anomaly detection
        if self.anomaly_detector and analysis['market_data']:
            try:
                logger.info("  ðŸ” Detecting anomalies...")
                for symbol, df in analysis['market_data'].items():
                    if len(df) >= 50:  # Need sufficient data
                        anomalies = self.anomaly_detector.detect_anomalies(df)
                        analysis['anomalies'][symbol] = anomalies
            except Exception as e:
                logger.error(f"âŒ Anomaly detection failed: {e}")
        
        # 5. AI predictions
        if self.meta_ensemble and analysis['market_data']:
            try:
                logger.info("  ðŸ§  Generating AI predictions...")
                for symbol, df in analysis['market_data'].items():
                    if len(df) >= 100:  # Need sufficient data
                        prediction = self.meta_ensemble.predict(df)
                        analysis['ai_predictions'][symbol] = prediction
            except Exception as e:
                logger.error(f"âŒ AI prediction failed: {e}")
        
        # 6. Advanced Regime detection
        if self.regime_manager and analysis.get('market_data'):
            try:
                # Convert market data to DataFrame for regime detection
                market_df = pd.DataFrame(analysis['market_data'])
                if not market_df.empty:
                    regime_metrics = self.regime_manager.update_regime(market_df)
                    analysis['regime'] = regime_metrics.regime.value
                    analysis['regime_confidence'] = regime_metrics.confidence
                    analysis['regime_features'] = self.regime_manager.get_regime_features()
                    
                    # Check if regime change should trigger escalation
                    if self.regime_manager.should_trigger_escalation():
                        analysis['regime_escalation'] = True
                        logger.info(f"Regime change detected: {regime_metrics.regime.value}")
            except Exception as e:
                logger.error(f"Error in regime detection: {e}")
                # Fallback to simple regime detection
                if analysis['volatility']:
                    analysis['regime'] = self._detect_market_regime(analysis['volatility'])
        else:
            # Fallback to simple regime detection
            if analysis['volatility']:
                analysis['regime'] = self._detect_market_regime(analysis['volatility'])
        
        logger.info("Market analysis complete!")
        return analysis
    
    def _detect_market_regime(self, volatility_data: Dict) -> str:
        """Detect current market regime"""
        avg_vol = np.mean([v.get('volatility', 0) for v in volatility_data.values()])
        
        if avg_vol > 0.03:
            return 'high_volatility'
        elif avg_vol > 0.015:
            return 'normal'
        else:
            return 'low_volatility'
    
    def make_trading_decision(self, analysis: Dict) -> Dict:
        """
        AI makes autonomous trading decision using Hybrid Control Plane
        
        Uses:
        - Meta-Ensemble Blender for deterministic fusion
        - Hybrid Control Plane for risk management
        - Local Reasoner for conflict resolution
        - GPT-5 for escalations only
        """
        logger.info("Making Trading Decision with Hybrid Control Plane...")
        log_ai_activity('decision_making', 'Starting AI trading decision process', {
            'analysis_components': list(analysis.keys()),
            'market_data_available': bool(analysis.get('market_data')),
            'ai_predictions_available': bool(analysis.get('ai_predictions'))
        })
        
        # Update hybrid control plane with current portfolio state
        if self.hybrid_control:
            portfolio_state = {
                'net_liquidity': self.current_capital,
                'daily_pnl': calculate_daily_pnl(self.trades, self.initial_capital),
                'max_drawdown_5d': calculate_max_drawdown_5d(self.trades, self.initial_capital),
                'volatility_zscore': calculate_volatility_zscore(self.trades),
                'correlation_breakdown': 0.5,  # Default neutral
                'ensemble_accuracy': calculate_ensemble_accuracy(self.trades),
                'sharpe_ratio': calculate_sharpe_ratio(self.trades, self.initial_capital),
                'put_call_ratio': 1.0  # Default neutral
            }
            self.hybrid_control.update_portfolio_state(portfolio_state)
        
        # Use meta-ensemble blender for decision fusion
        if self.meta_blender:
            # Convert analysis to prediction signals
            predictions = convert_analysis_to_predictions(analysis)
            
            # Update market state for risk adjustments
            market_state = {
                'volatility_spike': abs(calculate_volatility_zscore(self.trades)) > 2.0,
                'news_sentiment': 0.0,  # Default neutral
                'liquidity_score': 1.0,  # Default high liquidity
                'correlation_breakdown': False  # Default no breakdown
            }
            self.meta_blender.update_market_state(market_state)
            
            # Blend predictions
            blended_decisions = self.meta_blender.blend_predictions(predictions)
            
            # Get the best decision
            if blended_decisions:
                best_symbol = max(blended_decisions.keys(), 
                                key=lambda s: blended_decisions[s].score)
                best_decision = blended_decisions[best_symbol]
                
                decision = {
                    'timestamp': datetime.now(),
                    'action': best_decision.action.value,
                    'symbol': best_decision.symbol,
                    'shares': best_decision.position_size_post_risk,
                    'price': 100.0,  # Default price
                    'confidence': best_decision.confidence,
                    'reasoning': best_decision.reasoning,
                    'risk_score': 1.0 - best_decision.confidence
                }
                
                logger.info(f"ðŸŽ¯ Meta-Ensemble Decision: {decision['action']} {decision['symbol']} (score: {best_decision.score:.3f})")
                
                # Log the decision
                log_ai_decision(
                    decision_type='meta_ensemble',
                    symbol=decision['symbol'],
                    decision=f"{decision['action']} {decision['shares']:.2f} shares",
                    reasoning=decision['reasoning'],
                    risk_factors={'confidence': decision['confidence'], 'risk_score': decision['risk_score']}
                )
                
                return decision
        
        # Fallback to original logic if hybrid control not available
        decision = {
            'timestamp': datetime.now(),
            'action': 'HOLD',  # BUY, SELL, HOLD
            'symbol': None,
            'shares': 0.0,
            'price': 0.0,
            'confidence': 0.0,
            'reasoning': ['Hybrid control not available'],
            'risk_score': 0.0
        }
        
        # Collect all signals
        signals = []
        
        # 1. AI Model Signals
        if analysis.get('ai_predictions'):
            for symbol, pred in analysis['ai_predictions'].items():
                if pred.get('direction') == 'UP' and pred.get('confidence', 0) > 0.7:
                    signals.append({
                        'type': 'AI_MODEL',
                        'symbol': symbol,
                        'action': 'BUY',
                        'strength': pred['confidence'],
                        'reason': f"AI predicts {pred['confidence']*100:.1f}% upside"
                    })
                elif pred.get('direction') == 'DOWN' and pred.get('confidence', 0) > 0.7:
                    if symbol in self.holdings:
                        signals.append({
                            'type': 'AI_MODEL',
                            'symbol': symbol,
                            'action': 'SELL',
                            'strength': pred['confidence'],
                            'reason': f"AI predicts {pred['confidence']*100:.1f}% downside"
                        })
        
        # 2. Sentiment Signals
        if analysis.get('sentiment'):
            for symbol, sent in analysis['sentiment'].items():
                if sent.get('compound', 0) > 0.5:
                    signals.append({
                        'type': 'SENTIMENT',
                        'symbol': symbol,
                        'action': 'BUY',
                        'strength': sent['compound'],
                        'reason': f"Positive sentiment: {sent['compound']:.2f}"
                    })
                elif sent.get('compound', 0) < -0.5 and symbol in self.holdings:
                    signals.append({
                        'type': 'SENTIMENT',
                        'symbol': symbol,
                        'action': 'SELL',
                        'strength': abs(sent['compound']),
                        'reason': f"Negative sentiment: {sent['compound']:.2f}"
                    })
        
        # 3. Volatility Signals
        if analysis.get('volatility'):
            for symbol, vol in analysis['volatility'].items():
                if vol.get('regime') == 'breakout' and analysis['regime'] != 'high_volatility':
                    signals.append({
                        'type': 'VOLATILITY',
                        'symbol': symbol,
                        'action': 'BUY',
                        'strength': 0.6,
                        'reason': "Volatility breakout detected"
                    })
        
        # 4. Anomaly Signals
        if analysis.get('anomalies'):
            for symbol, anomalies in analysis['anomalies'].items():
                if len(anomalies) > 0:
                    logger.info(f"  âš ï¸ Anomaly detected in {symbol}: {len(anomalies)} events")
        
        # 5. Options Flow Signals (if available)
        if analysis.get('options_flow'):
            for symbol, options in analysis['options_flow'].items():
                if options.get('call_volume', 0) > options.get('put_volume', 0) * 2:
                    signals.append({
                        'type': 'OPTIONS_FLOW',
                        'symbol': symbol,
                        'action': 'BUY',
                        'strength': 0.5,
                        'reason': "Heavy call buying detected"
                    })
        
        # Aggregate signals and make decision
        if signals:
            # Group by symbol and action
            symbol_scores = {}
            for signal in signals:
                key = (signal['symbol'], signal['action'])
                if key not in symbol_scores:
                    symbol_scores[key] = {
                        'symbol': signal['symbol'],
                        'action': signal['action'],
                        'total_strength': 0.0,
                        'reasons': [],
                        'signal_count': 0
                    }
                symbol_scores[key]['total_strength'] += signal['strength']
                symbol_scores[key]['reasons'].append(signal['reason'])
                symbol_scores[key]['signal_count'] += 1
            
            # Find strongest signal
            best_signal = max(symbol_scores.values(), key=lambda x: x['total_strength'])
            
            # ChatGPT Analysis Integration
            if self.chatgpt and best_signal['total_strength'] >= 0.5:  # Lower threshold for ChatGPT review
                try:
                    logger.info("Getting ChatGPT analysis...")
                    
                    # Prepare market data for ChatGPT
                    chatgpt_data = {
                        'basic_market_data': analysis.get('market_data', {}),
                        'news_sentiment': analysis.get('news_sentiment', {}),
                        'technical_indicators': analysis.get('technical_indicators', {})
                    }
                    
                    # Get ChatGPT analysis
                    chatgpt_analysis = self.chatgpt.analyze_market_conditions(chatgpt_data)
                    
                    # Get specific trading decision for the best symbol
                    if best_signal['symbol']:
                        chatgpt_decision = self.chatgpt.get_trading_decision(
                            best_signal['symbol'], chatgpt_data
                        )
                        
                        # Integrate ChatGPT decision
                        if chatgpt_decision.get('action') != 'HOLD':
                            # Weight ChatGPT decision
